<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module aiutp_pcb_timeout</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module aiutp_pcb_timeout</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>uTP 协议控制块的超时处理模块.

<p><b>References</b><ul><li>libutp: https://github.com/bittorrent/libutp</li></ul></p>

<h2><a name="description">Description</a></h2><p>uTP 协议控制块的超时处理模块</p>
 
  <p>本模块实现 uTP 协议中的超时检测和处理逻辑，对齐 libutp 实现。</p>
 
  <h3><a name="超时类型">超时类型</a></h3>
 
  <h4><a name="RTO_超时（重传超时）">RTO 超时（重传超时）</a></h4><p>  
- 当 rto_timeout 到期且有未确认的包时触发  
- 执行指数退避：RTO *= 2（libutp 标准）  
- 标记所有未确认包为需要重发  
- 重置拥塞窗口到 1 个包大小，启用慢启动</p>
 
  <h4><a name="Keepalive_超时">Keepalive 超时</a></h4><p>  
- 每 KEEPALIVE_INTERVAL (29秒) 发送一次心跳  
- 用于保持 NAT 映射和检测死连接  
- 如果 2 * KEEPALIVE_INTERVAL 内没有收到包，关闭连接</p>
 
  <h4><a name="连接超时">连接超时</a></h4><p>  
- SYN_SENT: 最多重试 MAX_SYN_RETRIES (2) 次  
- 其他状态: 最多重试 MAX_RETRANSMIT_COUNT (4) 次  
- 超过限制后发送 RESET 并销毁连接</p>
 
  <h4><a name="零窗口探测">零窗口探测</a></h4>
  - 当对端通告零窗口时启用
  - 定期尝试恢复窗口
 
<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#check_timeouts-1">check_timeouts/1</a></td><td>超时检查的主入口点.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="check_timeouts-1">check_timeouts/1</a></h3>
<div class="spec">
<p><code>check_timeouts(Aiutp_pcb::#aiutp_pcb{conn_id_recv = non_neg_integer() | undefined, conn_id_send = non_neg_integer() | undefined, socket = {<a href="/home/david/workspace/kernel/doc/gen_udp.html#type-socket" docgen-rel="seetype" docgen-href="kernel:gen_udp#socket/0">gen_udp:socket()</a>, {<a href="/home/david/workspace/kernel/doc/inet.html#type-ip_address" docgen-rel="seetype" docgen-href="kernel:inet#ip_address/0">inet:ip_address()</a>, <a href="/home/david/workspace/kernel/doc/inet.html#type-port_number" docgen-rel="seetype" docgen-href="kernel:inet#port_number/0">inet:port_number()</a>}} | undefined, state = atom(), close_requested = boolean(), seq_nr = non_neg_integer(), ack_nr = non_neg_integer(), fast_resend_seq_nr = non_neg_integer(), got_fin = boolean(), got_fin_reached = boolean(), fin_sent = boolean(), fin_sent_acked = boolean(), eof_pkt = non_neg_integer(), cur_window = non_neg_integer(), cur_window_packets = non_neg_integer(), max_window = non_neg_integer(), max_window_user = non_neg_integer(), last_rcv_win = non_neg_integer(), last_rwin_decay = non_neg_integer(), rtt = non_neg_integer(), rtt_var = non_neg_integer(), rto = non_neg_integer(), rtt_hist = any(), retransmit_timeout = non_neg_integer(), rto_timeout = non_neg_integer(), target_delay = non_neg_integer(), ssthresh = non_neg_integer(), slow_start = boolean(), last_maxed_out_window = non_neg_integer(), our_hist = any(), their_hist = any(), average_delay = integer(), current_delay_sum = integer(), current_delay_samples = non_neg_integer(), average_delay_base = non_neg_integer(), average_sample_time = non_neg_integer(), last_measured_delay = non_neg_integer(), clock_drift = integer(), retransmit_count = non_neg_integer(), duplicate_ack = non_neg_integer(), fast_timeout = boolean(), reorder_count = non_neg_integer(), time = non_neg_integer() | undefined, recv_time = non_neg_integer() | undefined, last_got_packet = non_neg_integer(), last_sent_packet = non_neg_integer(), reply_micro = non_neg_integer(), zerowindow_time = non_neg_integer(), inbuf = any(), outbuf = any(), inque = any(), outque = any(), ida = boolean(), mtu_floor = non_neg_integer(), mtu_ceiling = non_neg_integer(), mtu_last = non_neg_integer(), mtu_probe_seq = non_neg_integer(), mtu_probe_size = non_neg_integer(), mtu_discover_time = non_neg_integer(), mtu_probe_failures = non_neg_integer()}) -&gt; #aiutp_pcb{conn_id_recv = non_neg_integer() | undefined, conn_id_send = non_neg_integer() | undefined, socket = {<a href="/home/david/workspace/kernel/doc/gen_udp.html#type-socket" docgen-rel="seetype" docgen-href="kernel:gen_udp#socket/0">gen_udp:socket()</a>, {<a href="/home/david/workspace/kernel/doc/inet.html#type-ip_address" docgen-rel="seetype" docgen-href="kernel:inet#ip_address/0">inet:ip_address()</a>, <a href="/home/david/workspace/kernel/doc/inet.html#type-port_number" docgen-rel="seetype" docgen-href="kernel:inet#port_number/0">inet:port_number()</a>}} | undefined, state = atom(), close_requested = boolean(), seq_nr = non_neg_integer(), ack_nr = non_neg_integer(), fast_resend_seq_nr = non_neg_integer(), got_fin = boolean(), got_fin_reached = boolean(), fin_sent = boolean(), fin_sent_acked = boolean(), eof_pkt = non_neg_integer(), cur_window = non_neg_integer(), cur_window_packets = non_neg_integer(), max_window = non_neg_integer(), max_window_user = non_neg_integer(), last_rcv_win = non_neg_integer(), last_rwin_decay = non_neg_integer(), rtt = non_neg_integer(), rtt_var = non_neg_integer(), rto = non_neg_integer(), rtt_hist = any(), retransmit_timeout = non_neg_integer(), rto_timeout = non_neg_integer(), target_delay = non_neg_integer(), ssthresh = non_neg_integer(), slow_start = boolean(), last_maxed_out_window = non_neg_integer(), our_hist = any(), their_hist = any(), average_delay = integer(), current_delay_sum = integer(), current_delay_samples = non_neg_integer(), average_delay_base = non_neg_integer(), average_sample_time = non_neg_integer(), last_measured_delay = non_neg_integer(), clock_drift = integer(), retransmit_count = non_neg_integer(), duplicate_ack = non_neg_integer(), fast_timeout = boolean(), reorder_count = non_neg_integer(), time = non_neg_integer() | undefined, recv_time = non_neg_integer() | undefined, last_got_packet = non_neg_integer(), last_sent_packet = non_neg_integer(), reply_micro = non_neg_integer(), zerowindow_time = non_neg_integer(), inbuf = any(), outbuf = any(), inque = any(), outque = any(), ida = boolean(), mtu_floor = non_neg_integer(), mtu_ceiling = non_neg_integer(), mtu_last = non_neg_integer(), mtu_probe_seq = non_neg_integer(), mtu_probe_size = non_neg_integer(), mtu_discover_time = non_neg_integer(), mtu_probe_failures = non_neg_integer()}</code><br></p>
<p> </p>
<p>returns: 超时处理后的更新 PCB</p>
</div><p><p>超时检查的主入口点</p>
 
  定期调用以处理各种超时条件：
  1. 刷新待发送的包
  2. 检查 RTO 超时
  3. 检查 keepalive 超时
  4. 检查连接状态转换
 </p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
