# aiutp æ•°æ®å‘é€æµç¨‹ä¼˜åŒ–åˆ†ææŠ¥å‘Š

> æ—¥æœŸ: 2025-12-04
> åˆ†æèŒƒå›´: å‘é€æµç¨‹ã€æ€§èƒ½ç“¶é¢ˆã€ä¼˜åŒ–æœºä¼š
> å¯¹æ¯”å‚è€ƒ: libutp å®˜æ–¹å®ç°

## æ‰§è¡Œæ‘˜è¦

æœ¬æŠ¥å‘Šæ·±å…¥åˆ†æäº† aiutp é¡¹ç›®çš„æ•°æ®å‘é€æµç¨‹ï¼Œè¯†åˆ«äº†æ½œåœ¨çš„æ€§èƒ½ç“¶é¢ˆå’Œä¼˜åŒ–ç©ºé—´ã€‚åˆ†æç»“æœè¡¨æ˜ï¼Œaiutp åœ¨å‘é€ç­–ç•¥ä¸Š**å·²ç»å®ç°äº†å¤šé¡¹é‡è¦ä¼˜åŒ–**ï¼Œä½†ä»æœ‰å‡ ä¸ªæ–¹å‘å¯ä»¥è¿›ä¸€æ­¥æå‡æ€§èƒ½ã€‚

**å…³é”®å‘ç°**:
- âœ… **å·²å®ç°**: å°åŒ…åˆå¹¶ï¼ˆç±» Nagleï¼‰ã€iolist ç´¯ç§¯ä¼˜åŒ–ã€MTU å‘ç°
- âš ï¸ **å¯ä¼˜åŒ–**: UDP æ‰¹é‡å‘é€ï¼ˆsendmsgï¼‰ã€é›¶æ‹·è´ã€å®šæ—¶å™¨ç²’åº¦
- ğŸ” **æƒè¡¡**: å»¶è¿Ÿ vs ååé‡ã€ç®€å•æ€§ vs æ€§èƒ½

---

## 1. å½“å‰å®ç°åˆ†æ

### 1.1 æ•°æ®å‘é€å®Œæ•´æµç¨‹

```
ç”¨æˆ·åº”ç”¨
    â”‚
    â–¼
aiutp:send/2                    â† API å…¥å£
    â”‚
    â–¼
aiutp_pcb:write/2               â† å†™å…¥ PCB
    â”‚
    â–¼
aiutp_tx:in/2                   â† æ”¾å…¥å‘é€é˜Ÿåˆ— (outque)
    â”‚                              æ ¼å¼: {Type, Binary}
    â–¼
aiutp_net:flush_queue/1         â† åˆ·æ–°é˜Ÿåˆ—
    â”‚
    â”œâ”€â†’ max_send/1              â† è®¡ç®—å¯å‘é€å­—èŠ‚æ•°
    â”‚   (è€ƒè™‘æ‹¥å¡çª—å£å’Œå¯¹ç«¯çª—å£)
    â”‚
    â”œâ”€â†’ send_queued_data/1      â† ä»é˜Ÿåˆ—å–æ•°æ®
    â”‚       â”‚
    â”‚       â”œâ”€â†’ fill_from_queue/2    â† å°åŒ…åˆå¹¶ï¼ˆç±» Nagleï¼‰
    â”‚       â”‚   (ä½¿ç”¨ iolist ç´¯ç§¯ï¼Œé¿å…å¤šæ¬¡äºŒè¿›åˆ¶æ‹¼æ¥)
    â”‚       â”‚
    â”‚       â””â”€â†’ send_new_packet/4    â† åˆ›å»ºå¹¶å‘é€åŒ…
    â”‚               â”‚
    â”‚               â”œâ”€â†’ aiutp_mtu:should_probe/2  â† MTU æ¢æµ‹æ£€æŸ¥
    â”‚               â”œâ”€â†’ aiutp_packet:encode/1     â† ç¼–ç æ•°æ®åŒ…
    â”‚               â”œâ”€â†’ aiutp_buffer:append/2     â† åŠ å…¥ outbuf
    â”‚               â””â”€â†’ do_send/2                  â† UDP å‘é€
    â”‚
    â””â”€â†’ maybe_transition_to_full/1  â† çª—å£æ»¡æ—¶çŠ¶æ€è½¬æ¢
```

**ä¼˜ç‚¹**:
1. **å°åŒ…åˆå¹¶ä¼˜åŒ–** (`fill_from_queue/2`): å°½å¯èƒ½å¡«æ»¡ PACKET_SIZE (1296 å­—èŠ‚)
2. **iolist ç´¯ç§¯**: é¿å…å¤šæ¬¡äºŒè¿›åˆ¶æ‹¼æ¥çš„å¼€é”€
3. **çª—å£ç®¡ç†**: ä¸¥æ ¼éµå¾ª LEDBAT æ‹¥å¡æ§åˆ¶
4. **MTU å‘ç°**: åŠ¨æ€è°ƒæ•´åŒ…å¤§å°ä»¥é€‚åº”ç½‘ç»œè·¯å¾„

**æ•°æ®ç»“æ„**:
```erlang
%% outque: åº”ç”¨å±‚å†™å…¥çš„å¾…å‘é€æ•°æ®
%%   aiutp_queue:new() â†’ [{Type, Binary}]
%%
%% outbuf: å·²æ‰“åŒ…ä½†æœªç¡®è®¤çš„æ•°æ®åŒ…
%%   aiutp_buffer:new(1024) â†’ [#aiutp_packet_wrap{}]
%%
%% æµå‘: outque â†’ send_new_packet â†’ outbuf â†’ ACK åç§»é™¤
```

### 1.2 flush_queue å‘é€ç­–ç•¥è¯¦è§£

**æ ¸å¿ƒé€»è¾‘** (`aiutp_net.erl:419-565`):

```erlang
%% 1. æ£€æŸ¥çª—å£æ˜¯å¦å·²æ»¡
{IsFull, PCB2} = is_full(-1, PCB1),
case IsFull of
    true -> PCB2;  %% åœæ­¢å‘é€
    false -> send_queued_data(PCB2)
end

%% 2. ä»é˜Ÿåˆ—å–ä¸€ä¸ªå…ƒç´ 
{Type, Bin} = aiutp_queue:front(OutQue),
MaxSend = max_send(PCB),  %% è®¡ç®—å¯å‘é€å­—èŠ‚æ•°

%% 3. åˆ†ç‰‡å‘é€æˆ–å°åŒ…åˆå¹¶
case byte_size(Bin) =< ChunkSize of
    true ->
        %% å°æ•°æ®å—ï¼šå°è¯•ä»é˜Ÿåˆ—åˆå¹¶æ›´å¤šæ•°æ®
        fill_from_queue(ChunkSize - BinSize, Type, PCB);
    false ->
        %% å¤§æ•°æ®å—ï¼šåˆ†ç‰‡å‘é€
        <<Data:ChunkSize/binary, Rest/binary>> = Bin,
        send_new_packet(Type, Data, ChunkSize, PCB)
end
```

**å°åŒ…åˆå¹¶æœºåˆ¶** (ç±»ä¼¼ Nagle ç®—æ³•):

```erlang
%% fill_from_queue_loop/5 ä½¿ç”¨ iolist ç´¯ç§¯ä¼˜åŒ–
fill_from_queue_loop(RequiredSize, Type, AccList, AccSize, PCB) ->
    case aiutp_queue:front(OutQue) of
        {Type, Bin} ->  %% ç›¸åŒç±»å‹ï¼Œç»§ç»­åˆå¹¶
            [Bin | AccList]  %% ç´¯ç§¯åˆ° iolist
        _ ->
            %% ä¸åŒç±»å‹ï¼Œç»ˆæ­¢åˆå¹¶
            iolist_to_binary(lists:reverse(AccList))
    end.
```

**è§¦å‘æ¡ä»¶**:
- âœ… **åˆå¹¶**: å½“å‰æ•°æ® < PACKET_SIZE ä¸”é˜Ÿåˆ—ä¸­æœ‰ç›¸åŒç±»å‹æ•°æ®
- âœ… **å‘é€**: ç´¯ç§¯æ•°æ® >= PACKET_SIZE æˆ–é˜Ÿåˆ—ä¸­æ— æ›´å¤šç›¸åŒç±»å‹æ•°æ®
- âœ… **ç±»å‹éš”ç¦»**: ä¸åŒç±»å‹ï¼ˆST_DATA, ST_FINï¼‰ä¸ä¼šåˆå¹¶

**Reason**: è¿™æ˜¯ä¸€ä¸ª**ä¸»åŠ¨åˆå¹¶ç­–ç•¥**ï¼Œä¸ TCP Nagle çš„"ç­‰å¾… ACK"ä¸åŒã€‚
aiutp é€‰æ‹©"å°½é‡å¡«æ»¡åŒ…"è€Œé"ç­‰å¾…ç¡®è®¤"ï¼Œå› ä¸ºï¼š
1. uTP åŸºäº UDPï¼Œæ²¡æœ‰ TCP çš„æµæ§æœºåˆ¶
2. LEDBAT æ‹¥å¡æ§åˆ¶å·²ç»æä¾›äº†å»¶è¿Ÿæ•æ„Ÿçš„çª—å£ç®¡ç†
3. ä¸»åŠ¨åˆå¹¶åœ¨ä½è´Ÿè½½æ—¶å‡å°‘å»¶è¿Ÿï¼Œé«˜è´Ÿè½½æ—¶è‡ªç„¶å¡«æ»¡

### 1.3 flush_packets é‡ä¼ ç­–ç•¥

**è§¦å‘åœºæ™¯**:
1. **å‘¨æœŸæ€§ tick** (50ms å®šæ—¶å™¨): `aiutp_channel:connected/3`
2. **æ”¶åˆ° ACK å**: `aiutp_pcb:process_incoming/2`
3. **å¿«é€Ÿé‡ä¼ **: SACK è§¦å‘æˆ–é‡å¤ ACK

**æ ¸å¿ƒé€»è¾‘** (`aiutp_net.erl:121-125`):

```erlang
flush_packets(#aiutp_pcb{outbuf = OutBuf} = PCB) ->
    Iter = aiutp_buffer:head(OutBuf),
    flush_packets_loop(Iter, PCB).

flush_packets_loop(Iter, PCB) ->
    WrapPacket = aiutp_buffer:data(Iter, OutBuf),
    ShouldSend = (WrapPacket#aiutp_packet_wrap.transmissions == 0) orelse
                 (WrapPacket#aiutp_packet_wrap.need_resend == true),
    case ShouldSend of
        true -> send_packet(Iter, PCB1);
        false -> flush_packets_loop(Next, PCB1)
    end.
```

**å‘é€æ¡ä»¶**:
- `transmissions == 0`: æ–°åŒ…ï¼Œä»æœªå‘é€è¿‡
- `need_resend == true`: æ ‡è®°ä¸ºé‡ä¼ ï¼ˆRTO è¶…æ—¶æˆ– SACK è§¦å‘ï¼‰

**Reason**: éå†æ•´ä¸ª outbuf ç¡®ä¿æ‰€æœ‰å¾…å‘é€/é‡ä¼ çš„åŒ…éƒ½è¢«å¤„ç†ã€‚
æ€§èƒ½è€ƒè™‘ï¼šoutbuf æœ€å¤§ 1024 åŒ…ï¼Œéå†å¼€é”€å¯æ¥å—ã€‚

### 1.4 UDP å‘é€å®ç°

**å½“å‰å®ç°** (`aiutp_net.erl:869-896`):

```erlang
do_send({Socket, Remote}, Content) ->
    do_send_with_retry(Socket, Remote, 3, Content).

do_send_with_retry(Socket, Remote, Count, Content) ->
    case gen_udp:send(Socket, Remote, Content) of
        ok -> ok;
        {error, Reason} ->
            case Count of
                0 -> {error, Reason};  %% é‡è¯•è€—å°½
                _ ->
                    timer:sleep(150),  %% å»¶è¿Ÿ 150ms
                    do_send_with_retry(Socket, Remote, Count - 1, Content)
            end
    end.
```

**ç‰¹ç‚¹**:
- **æ¯åŒ…ä¸€æ¬¡ç³»ç»Ÿè°ƒç”¨**: `gen_udp:send/3` æ¯æ¬¡å‘é€ä¸€ä¸ª UDP åŒ…
- **é”™è¯¯é‡è¯•**: æœ€å¤šé‡è¯• 3 æ¬¡ï¼Œé—´éš” 150ms
- **åŒæ­¥å‘é€**: å‘é€å¤±è´¥ä¼šé˜»å¡é‡è¯•

**æ€§èƒ½å½±å“**:
- âŒ æ¯åŒ…ä¸€æ¬¡ç³»ç»Ÿè°ƒç”¨å¼€é”€ï¼ˆç”¨æˆ·æ€ â†” å†…æ ¸æ€åˆ‡æ¢ï¼‰
- âŒ æ— æ³•åˆ©ç”¨æ“ä½œç³»ç»Ÿæ‰¹é‡å‘é€ä¼˜åŒ–
- âœ… ç®€å•å¯é ï¼Œé”™è¯¯å¤„ç†æ¸…æ™°

---

## 2. libutp å‘é€ç­–ç•¥å¯¹æ¯”

### 2.1 libutp æ˜¯å¦ä½¿ç”¨ Nagle ç®—æ³•ï¼Ÿ

**ç»“è®º**: âŒ **libutp ä¸å®ç°ä¼ ç»Ÿ Nagle ç®—æ³•**

**è¯æ®åˆ†æ**:

1. **BEP-29 è§„èŒƒ**æœªæåŠ Nagle æˆ–å°åŒ…åˆå¹¶
2. **libutp æºç **(`utp_internal.cpp`) æ˜¾ç¤º**ç«‹å³å‘é€ç­–ç•¥**:

```cpp
// libutp: UTP_Write ç«‹å³å°è¯•æ‰“åŒ…å¹¶å‘é€
size_t UTP_Write(utp_socket *conn, size_t count) {
    // ä¸ç­‰å¾…ç´¯ç§¯ï¼Œç›´æ¥æ‰“åŒ…
    while (count > 0 && !is_full()) {
        size_t packet_size = min(count, get_packet_size());
        send_data(packet, packet_size);
        count -= packet_size;
    }
}
```

**Reason**: uTP è®¾è®¡ç†å¿µæ˜¯"ä½å»¶è¿Ÿ"ï¼ŒNagle çš„"ç­‰å¾… ACK æˆ–ç´¯ç§¯"ä¼šå¢åŠ å»¶è¿Ÿã€‚
LEDBAT æ‹¥å¡æ§åˆ¶å·²ç»æä¾›äº†è¶³å¤Ÿçš„æµé‡ç®¡ç†ï¼Œæ— éœ€ Nagle çš„é¢å¤–èŠ‚æµã€‚

### 2.2 libutp æ‰¹é‡å‘é€æœºåˆ¶

**è°ƒæŸ¥ç»“æœ**: âŒ **libutp æœªä½¿ç”¨ sendmsg æ‰¹é‡å‘é€**

**libutp å‘é€æµç¨‹**:
```cpp
void utp_socket::send_data(...) {
    // ç¼–ç åŒ…
    byte *p = packet_buffer;
    encode_packet_header(p, ...);

    // å•æ¬¡å‘é€
    sendto(socket, packet_buffer, packet_size, 0, &addr, addr_len);
}
```

**å¯¹æ¯” aiutp**:
```erlang
%% aiutp: åŒæ ·æ˜¯å•åŒ…å‘é€
do_send({Socket, Remote}, Content) ->
    gen_udp:send(Socket, Remote, Content).
```

**ç»“è®º**: âœ… **aiutp ä¸ libutp å‘é€ç­–ç•¥ä¸€è‡´** - å•åŒ…å•æ¬¡ç³»ç»Ÿè°ƒç”¨

**Reason**:
1. UDP æœ¬èº«æ˜¯é¢å‘æ¶ˆæ¯çš„ï¼Œæ‰¹é‡å‘é€æ”¶ç›Šæœ‰é™
2. uTP çš„åŒ…åºåˆ—å·å’Œæ—¶é—´æˆ³è¦æ±‚æ¯åŒ…ç‹¬ç«‹ç¼–ç 
3. æ‰¹é‡å‘é€ä¼šå¢åŠ å®ç°å¤æ‚åº¦

### 2.3 libutp å®šæ—¶å™¨é¢‘ç‡

**libutp å»ºè®®** (`README.md`):
> You should call `utp_check_timeouts()` periodically, **about once per second or more frequently** if needed.

**å®é™…åº”ç”¨**:
- **BitTorrent å®¢æˆ·ç«¯**: é€šå¸¸ 50-100ms è°ƒç”¨ä¸€æ¬¡
- **libutp å†…éƒ¨èŠ‚æµ**: `TIMEOUT_CHECK_INTERVAL = 500ms`

**aiutp å®ç°**:
```erlang
%% aiutp_channel.erl
-define(CHANNEL_TICK_INTERVAL, 50).  %% å¤–å±‚å®šæ—¶å™¨

%% aiutp_pcb_timeout.erl
-define(TIMEOUT_CHECK_INTERVAL, 500).  %% å†…å±‚èŠ‚æµ
```

**å¯¹æ¯”**:
| é¡¹ç›® | å¤–å±‚å®šæ—¶å™¨ | å†…å±‚èŠ‚æµ | å¯¹é½çŠ¶æ€ |
|------|-----------|---------|---------|
| aiutp | 50ms | 500ms | âœ… å¯¹é½ |
| libutp | åº”ç”¨å±‚è°ƒç”¨ | 500ms | âœ… å¯¹é½ |

**ç»“è®º**: âœ… **aiutp å®šæ—¶å™¨ç­–ç•¥ä¸ libutp æ¨èä¸€è‡´**

---

## 3. æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

### 3.1 ç³»ç»Ÿè°ƒç”¨å¼€é”€

**é—®é¢˜**: æ¯åŒ…ä¸€æ¬¡ `gen_udp:send/3` è°ƒç”¨

**é‡åŒ–åˆ†æ**:
```
å‡è®¾åœºæ™¯: 10 Mbps ååé‡ï¼ŒPACKET_SIZE = 1296 å­—èŠ‚

åŒ…é€Ÿç‡ = 10,000,000 / 8 / 1296 â‰ˆ 964 åŒ…/ç§’
ç³»ç»Ÿè°ƒç”¨é¢‘ç‡ = 964 æ¬¡/ç§’

æ¯æ¬¡ç³»ç»Ÿè°ƒç”¨å¼€é”€ â‰ˆ 1-5 å¾®ç§’ï¼ˆå–å†³äºç³»ç»Ÿï¼‰
æ€»å¼€é”€ â‰ˆ 0.964 - 4.82 ms/ç§’ â‰ˆ 0.1-0.5% CPU
```

**ç»“è®º**: âš ï¸ **åœ¨é«˜ååé‡åœºæ™¯ä¸‹ï¼Œç³»ç»Ÿè°ƒç”¨å¼€é”€å¯å¿½ç•¥**

**åŸå› **:
1. Erlang VM çš„ scheduler å·²ç»ä¼˜åŒ–äº†ç³»ç»Ÿè°ƒç”¨
2. ç°ä»£æ“ä½œç³»ç»Ÿçš„ sendto éå¸¸é«˜æ•ˆ
3. æ‹¥å¡æ§åˆ¶æœ¬èº«ä¼šé™åˆ¶å‘é€é€Ÿç‡

### 3.2 äºŒè¿›åˆ¶æ•°æ®æ‹·è´

**å½“å‰å®ç°åˆ†æ**:

```erlang
%% 1. iolist ç´¯ç§¯ï¼ˆä¼˜åŒ–ï¼‰
fill_from_queue_loop(...) ->
    [Bin | AccList],  %% ä¸æ‹·è´ï¼Œåªå¼•ç”¨
    iolist_to_binary(lists:reverse(AccList))  %% ä¸€æ¬¡æ€§æ‹·è´

%% 2. åŒ…ç¼–ç ï¼ˆä¸å¯é¿å…ï¼‰
aiutp_packet:encode(Packet) ->
    <<Type:4, Ver:4, Ext:8, ConnId:16, ...>>  %% æ„å»ºäºŒè¿›åˆ¶

%% 3. UDP å‘é€ï¼ˆErlang VM ä¼˜åŒ–ï¼‰
gen_udp:send(Socket, Remote, Content)  %% VM å†…éƒ¨å¯èƒ½é›¶æ‹·è´
```

**ä¼˜åŒ–ç‚¹**:
- âœ… **å·²ä¼˜åŒ–**: ä½¿ç”¨ iolist é¿å…å¤šæ¬¡æ‹¼æ¥
- âœ… **æ— éœ€ä¼˜åŒ–**: Erlang binary å¼•ç”¨è®¡æ•°æœºåˆ¶
- âš ï¸ **æ½œåœ¨ä¼˜åŒ–**: åŒ…å¤´é¢„åˆ†é…ï¼ˆè§ 3.4.3ï¼‰

### 3.3 ç¼“å†²åŒºéå†

**flush_packets æ€§èƒ½**:

```erlang
%% æœ€åæƒ…å†µï¼šéå†æ•´ä¸ª outbuf (1024 åŒ…)
flush_packets_loop(Iter, PCB) ->
    WrapPacket = aiutp_buffer:data(Iter, OutBuf),  %% O(1) æ•°ç»„è®¿é—®
    Next = aiutp_buffer:next(Iter, OutBuf),        %% O(1) é“¾è¡¨éå†
    ...
```

**å¤æ‚åº¦**: O(n)ï¼Œn = outbuf ä¸­çš„åŒ…æ•°ï¼ˆæœ€å¤§ 1024ï¼‰

**å®é™…å¼€é”€**:
- æ¯æ¬¡ tick (50ms) æ‰§è¡Œä¸€æ¬¡
- å¤§éƒ¨åˆ†åŒ… `transmissions > 0` ä¸” `need_resend == false`ï¼Œå¿«é€Ÿè·³è¿‡
- åªæœ‰æ–°åŒ…æˆ–é‡ä¼ åŒ…æ‰è°ƒç”¨ `send_packet`

**ç»“è®º**: âœ… **éå†å¼€é”€å¯æ¥å—**ï¼Œæ— éœ€ä¼˜åŒ–

### 3.4 æ½œåœ¨ä¼˜åŒ–ç©ºé—´

#### 3.4.1 UDP æ‰¹é‡å‘é€ï¼ˆsendmmsgï¼‰

**æŠ€æœ¯**: Linux `sendmmsg(2)` ç³»ç»Ÿè°ƒç”¨

**åŸç†**: ä¸€æ¬¡ç³»ç»Ÿè°ƒç”¨å‘é€å¤šä¸ª UDP åŒ…

```c
// C ä¼ªä»£ç 
struct mmsghdr msgs[N];
for (i = 0; i < N; i++) {
    msgs[i].msg_hdr.msg_iov = &iovecs[i];
    msgs[i].msg_hdr.msg_iovlen = 1;
}
sendmmsg(sockfd, msgs, N, 0);  // ä¸€æ¬¡å‘é€ N ä¸ªåŒ…
```

**æ”¶ç›Šè¯„ä¼°**:
- âœ… **å‡å°‘ç³»ç»Ÿè°ƒç”¨**: N ä¸ªåŒ… â†’ 1 æ¬¡è°ƒç”¨
- âœ… **æé«˜ååé‡**: é«˜è´Ÿè½½åœºæ™¯ä¸‹ 10-30% æå‡
- âŒ **å¢åŠ å»¶è¿Ÿ**: éœ€è¦ç´¯ç§¯ N ä¸ªåŒ…æ‰å‘é€
- âŒ **å¤æ‚åº¦**: Erlang éœ€è¦ NIF å®ç°

**é€‚ç”¨åœºæ™¯**:
- é«˜ååé‡ä¼ è¾“ï¼ˆ> 50 Mbpsï¼‰
- æ‰¹é‡é‡ä¼ åœºæ™¯

**é£é™©**:
- âš ï¸ Erlang ç”Ÿæ€ç³»ç»Ÿæ— ç°æˆåº“
- âš ï¸ éœ€è¦ç»´æŠ¤ NIF ä»£ç 
- âš ï¸ å¯èƒ½ç ´å LEDBAT æ—¶åºç²¾åº¦

**å»ºè®®**: ğŸ“Š **ä½ä¼˜å…ˆçº§** - æ”¶ç›Šæœ‰é™ï¼Œå¤æ‚åº¦é«˜

#### 3.4.2 é›¶æ‹·è´å‘é€

**æŠ€æœ¯**: `sendfile(2)` æˆ– `MSG_ZEROCOPY`

**é€‚ç”¨æ€§åˆ†æ**:
```
uTP åŒ…ç»“æ„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Header   â”‚ Payload â”‚
â”‚ (20å­—èŠ‚) â”‚ (å˜é•¿)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é—®é¢˜ï¼š
1. Header éœ€è¦åŠ¨æ€ç”Ÿæˆï¼ˆseq_nr, timestamp, ack_nrï¼‰
2. Payload æ¥è‡ªåº”ç”¨å±‚ binaryï¼ˆå·²åœ¨ VM å †ä¸­ï¼‰
3. sendfile ä»…é€‚ç”¨äºæ–‡ä»¶ â†’ socketï¼Œä¸é€‚åˆå†…å­˜ â†’ socket
```

**ç»“è®º**: âŒ **ä¸é€‚ç”¨äº uTP åè®®**

#### 3.4.3 åŒ…å¤´é¢„åˆ†é…

**æ€è·¯**: é¢„åˆ†é…åŒ…å¤´ç¼“å†²åŒºï¼Œå‡å°‘ binary æ„å»ºå¼€é”€

**å½“å‰å®ç°**:
```erlang
encode(Packet) ->
    <<Type:4, Ver:4, Ext:8, ConnId:16, Timestamp:32, ...>>  %% æ¯æ¬¡æ„å»º
```

**ä¼˜åŒ–æ–¹æ¡ˆ**:
```erlang
%% é¢„åˆ†é…å›ºå®šéƒ¨åˆ†
HeaderTemplate = <<Ver:4, 0:4, 0:8, ConnId:16>>,
%% è¿è¡Œæ—¶åªå¡«å……å¯å˜å­—æ®µ
<<HeaderTemplate/binary, Timestamp:32, DelayMicro:32, ...>>
```

**æ”¶ç›Š**: âš ï¸ **å¾®å°** - Erlang binary æ„å»ºå·²é«˜åº¦ä¼˜åŒ–

**å»ºè®®**: âŒ **ä¸æ¨è** - å¤æ‚åº¦ > æ”¶ç›Š

#### 3.4.4 å®šæ—¶å™¨ç²’åº¦ä¼˜åŒ–

**å½“å‰å®ç°**: 50ms tick è§¦å‘ `flush_packets`

**é—®é¢˜åˆ†æ**:
```
æœ€åå»¶è¿Ÿ = åº”ç”¨ write + 50ms ç­‰å¾… + RTT
å¹³å‡å»¶è¿Ÿ = åº”ç”¨ write + 25ms ç­‰å¾… + RTT
```

**ä¼˜åŒ–æ–¹æ¡ˆ 1: ç«‹å³åˆ·æ–°**
```erlang
%% aiutp_tx:in/2 ä¿®æ”¹
in(Data, PCB) ->
    OutQue1 = aiutp_queue:push_back({?ST_DATA, Data}, OutQue),
    aiutp_net:flush_queue(PCB#aiutp_pcb{outque = OutQue1}).
    %% â†‘ å·²ç»æ˜¯è¿™æ ·å®ç°äº†ï¼
```

**ç»“è®º**: âœ… **å·²ä¼˜åŒ–** - `flush_queue` åœ¨ `write` æ—¶ç«‹å³è°ƒç”¨

**ä¼˜åŒ–æ–¹æ¡ˆ 2: è‡ªé€‚åº”å®šæ—¶å™¨**
```erlang
%% æ ¹æ®è´Ÿè½½åŠ¨æ€è°ƒæ•´ tick é—´éš”
case CurWindowPackets > 0 of
    true -> 10;   %% æœ‰åœ¨é€”åŒ…ï¼Œå¿«é€Ÿæ£€æŸ¥
    false -> 100  %% ç©ºé—²ï¼Œæ…¢é€Ÿæ£€æŸ¥
end
```

**æ”¶ç›Š**: âš ï¸ **æœ‰é™** - å¤§éƒ¨åˆ†æ—¶é—´å·²é€šè¿‡ç«‹å³åˆ·æ–°å¤„ç†

**å»ºè®®**: ğŸ“Š **ä¸­ä¼˜å…ˆçº§** - å¯ä½œä¸ºå¾®ä¼˜åŒ–

---

## 4. ä¼˜åŒ–å»ºè®®

### 4.1 é«˜ä¼˜å…ˆçº§ä¼˜åŒ–

#### æ—  - å½“å‰å®ç°å·²ä¼˜åŒ–è‰¯å¥½

**ç»“è®º**: aiutp å½“å‰çš„å‘é€å®ç°å·²ç»åŒ…å«äº†å…³é”®ä¼˜åŒ–ï¼š
1. âœ… å°åŒ…åˆå¹¶ï¼ˆ`fill_from_queue`ï¼‰
2. âœ… iolist ç´¯ç§¯ä¼˜åŒ–
3. âœ… ç«‹å³åˆ·æ–°ï¼ˆ`write` æ—¶è°ƒç”¨ `flush_queue`ï¼‰
4. âœ… MTU å‘ç°
5. âœ… å®šæ—¶å™¨èŠ‚æµï¼ˆ500msï¼‰

### 4.2 ä¸­ä¼˜å…ˆçº§ä¼˜åŒ–

#### 4.2.1 è‡ªé€‚åº”å®šæ—¶å™¨é—´éš”

**ç›®æ ‡**: æ ¹æ®è¿æ¥æ´»è·ƒåº¦åŠ¨æ€è°ƒæ•´ tick é—´éš”

**å®ç°æ–¹æ¡ˆ**:
```erlang
%% aiutp_channel.erl
calculate_tick_interval(PCB) ->
    case PCB#aiutp_pcb.cur_window_packets of
        0 -> 100;  %% ç©ºé—²è¿æ¥ï¼Œ100ms
        N when N < 10 -> 50;   %% ä½è´Ÿè½½ï¼Œ50ms
        _ -> 25    %% é«˜è´Ÿè½½ï¼Œ25msï¼ˆæ›´å¿«æ£€æµ‹é‡ä¼ ï¼‰
    end.
```

**é¢„æœŸæ”¶ç›Š**:
- ğŸŸ¢ ç©ºé—²è¿æ¥å‡å°‘ CPU ä½¿ç”¨
- ğŸŸ¢ é«˜è´Ÿè½½æ—¶æ›´å¿«å“åº”é‡ä¼ 
- ğŸ”´ å¢åŠ ä¸€ç‚¹ä»£ç å¤æ‚åº¦

**é£é™©**: âš ï¸ ä½ - ä»…å½±å“å®šæ—¶å™¨è°ƒåº¦

**å»ºè®®**: ğŸ“Š **å¯é€‰ä¼˜åŒ–** - æ€§ä»·æ¯”ä¸­ç­‰

#### 4.2.2 å‘é€ç¼“å†²åŒºå¤§å°ç›‘æ§

**ç›®æ ‡**: ç›‘æ§å¹¶æŠ¥å‘Šå‘é€ç¼“å†²åŒºä½¿ç”¨æƒ…å†µ

**å®ç°æ–¹æ¡ˆ**:
```erlang
%% æ·»åŠ  metrics å›è°ƒ
notify_buffer_usage(PCB) ->
    Usage = aiutp_buffer:count(PCB#aiutp_pcb.outbuf),
    case Usage > ?OUTGOING_BUFFER_MAX_SIZE * 0.8 of
        true ->
            %% è§¦å‘è­¦å‘Šæˆ–æµæ§
            logger:warning("outbuf usage: ~p/~p",
                          [Usage, ?OUTGOING_BUFFER_MAX_SIZE]);
        false -> ok
    end.
```

**é¢„æœŸæ”¶ç›Š**:
- ğŸŸ¢ æ—©æœŸå‘ç°æµæ§é—®é¢˜
- ğŸŸ¢ å¸®åŠ©è°ƒè¯•æ€§èƒ½ç“¶é¢ˆ

**é£é™©**: âœ… æ—  - ä»…å¢åŠ ç›‘æ§

**å»ºè®®**: âœ… **æ¨è** - æé«˜å¯è§‚æµ‹æ€§

### 4.3 ä½ä¼˜å…ˆçº§ä¼˜åŒ–

#### 4.3.1 UDP æ‰¹é‡å‘é€ï¼ˆsendmmsgï¼‰

**ä»…åœ¨ä»¥ä¸‹åœºæ™¯è€ƒè™‘**:
1. ååé‡ > 100 Mbps
2. æ„¿æ„ç»´æŠ¤ NIF ä»£ç 
3. å¯æ¥å—å¢åŠ çš„å»¶è¿Ÿ

**å®ç°å¤æ‚åº¦**: ğŸ”´ é«˜
- éœ€è¦ç¼–å†™ C NIF
- éœ€è¦å¤„ç†è·¨å¹³å°å…¼å®¹æ€§
- éœ€è¦å¤„ç†é”™è¯¯é‡è¯•

**é¢„æœŸæ”¶ç›Š**: ğŸŸ¡ ä¸­ç­‰ï¼ˆ10-30% ååé‡æå‡ï¼‰

**å»ºè®®**: â¸ï¸ **æš‚ä¸æ¨è** - ç­‰å¾…å®é™…æ€§èƒ½ç“¶é¢ˆå‡ºç°

---

## 5. æ€§èƒ½åŸºå‡†æµ‹è¯•å»ºè®®

### 5.1 æµ‹è¯•åœºæ™¯

**åœºæ™¯ 1: å•è¿æ¥ååé‡**
```erlang
%% æµ‹è¯•ç›®æ ‡: æœ€å¤§æŒç»­ååé‡
%% é…ç½®: å¤§æ–‡ä»¶ä¼ è¾“ï¼ˆ1 GBï¼‰ï¼Œæ— ä¸¢åŒ…
%% æŒ‡æ ‡: ååé‡ï¼ˆMbpsï¼‰ï¼ŒCPU ä½¿ç”¨ç‡
```

**åœºæ™¯ 2: å¤šè¿æ¥å¹¶å‘**
```erlang
%% æµ‹è¯•ç›®æ ‡: å¹¶å‘è¿æ¥æ‰©å±•æ€§
%% é…ç½®: 100 ä¸ªå¹¶å‘è¿æ¥ï¼Œæ¯ä¸ª 10 MB
%% æŒ‡æ ‡: æ€»ååé‡ï¼Œå†…å­˜ä½¿ç”¨ï¼Œè¿›ç¨‹è°ƒåº¦å»¶è¿Ÿ
```

**åœºæ™¯ 3: é«˜å»¶è¿Ÿç½‘ç»œ**
```erlang
%% æµ‹è¯•ç›®æ ‡: LEDBAT æ‹¥å¡æ§åˆ¶æ•ˆæœ
%% é…ç½®: RTT = 100ms, 5% ä¸¢åŒ…ç‡
%% æŒ‡æ ‡: ååé‡ï¼Œå»¶è¿Ÿç¨³å®šæ€§
```

**åœºæ™¯ 4: å°æ•°æ®ä¼ è¾“**
```erlang
%% æµ‹è¯•ç›®æ ‡: å°åŒ…åˆå¹¶æ•ˆæœ
%% é…ç½®: è¿ç»­å‘é€ 100 å­—èŠ‚æ•°æ®åŒ…
%% æŒ‡æ ‡: å®é™… UDP åŒ…æ•°é‡ï¼ŒåŒ…åˆ©ç”¨ç‡
```

### 5.2 å…³é”®æŒ‡æ ‡

| æŒ‡æ ‡ | æµ‹é‡æ–¹æ³• | ç›®æ ‡å€¼ |
|------|---------|--------|
| ååé‡ | æ–‡ä»¶ä¼ è¾“é€Ÿç‡ | > 10 Mbps (å•è¿æ¥) |
| å»¶è¿Ÿ | write â†’ ACK æ—¶é—´ | < RTT + 50ms |
| CPU ä½¿ç”¨ç‡ | 10 Mbps æ—¶çš„ CPU % | < 5% (å•æ ¸) |
| å†…å­˜ä½¿ç”¨ | 100 å¹¶å‘è¿æ¥ | < 100 MB |
| åŒ…åˆ©ç”¨ç‡ | payload / packet_size | > 90% (æŒç»­ä¼ è¾“) |

### 5.3 åŸºå‡†æµ‹è¯•å·¥å…·

**å»ºè®®ä½¿ç”¨**:
1. **basho_bench**: Erlang æ€§èƒ½æµ‹è¯•æ¡†æ¶
2. **tc (traffic control)**: Linux ç½‘ç»œæ¨¡æ‹Ÿå·¥å…·
3. **iperf3**: UDP ååé‡å‚è€ƒåŸºå‡†

**ç¤ºä¾‹é…ç½®**:
```bash
# æ¨¡æ‹Ÿ 100ms RTT, 5% ä¸¢åŒ…
tc qdisc add dev eth0 root netem delay 100ms loss 5%

# aiutp åŸºå‡†æµ‹è¯•
rebar3 as benchmark shell
```

---

## 6. ä¸ libutp çš„å¯¹é½æ€»ç»“

### 6.1 å‘é€ç­–ç•¥å¯¹æ¯”

| ç‰¹æ€§ | aiutp | libutp | å¯¹é½çŠ¶æ€ |
|------|-------|--------|---------|
| å°åŒ…åˆå¹¶ | âœ… fill_from_queue | âŒ æ—  | âš ï¸ aiutp æ›´ä¼˜ |
| Nagle ç®—æ³• | âŒ æ—  | âŒ æ—  | âœ… å¯¹é½ |
| æ‰¹é‡å‘é€ | âŒ æ—  | âŒ æ—  | âœ… å¯¹é½ |
| ç«‹å³åˆ·æ–° | âœ… write æ—¶åˆ·æ–° | âœ… write æ—¶å‘é€ | âœ… å¯¹é½ |
| å®šæ—¶å™¨é¢‘ç‡ | 50ms / 500ms | åº”ç”¨å±‚ / 500ms | âœ… å¯¹é½ |
| MTU å‘ç° | âœ… äºŒåˆ†æŸ¥æ‰¾ | âœ… äºŒåˆ†æŸ¥æ‰¾ | âœ… å¯¹é½ |

### 6.2 ä¼˜åŒ–æ€»ç»“

**aiutp å·²å®ç°çš„ä¼˜åŒ–**:
1. âœ… **å°åŒ…åˆå¹¶**: æ¯” libutp æ›´ä¸»åŠ¨åœ°å¡«æ»¡åŒ…
2. âœ… **iolist ç´¯ç§¯**: Erlang ç‰¹æœ‰ä¼˜åŒ–ï¼Œé¿å…å¤šæ¬¡æ‹·è´
3. âœ… **MTU å‘ç°**: ä¸ libutp ç®—æ³•ä¸€è‡´
4. âœ… **çª—å£ç®¡ç†**: ä¸¥æ ¼éµå¾ª LEDBAT

**aiutp ä¸ libutp çš„å·®å¼‚**:
1. âš ï¸ **è¯­è¨€å·®å¼‚**: Erlang vs C++ï¼ˆå½±å“ç³»ç»Ÿè°ƒç”¨æ–¹å¼ï¼‰
2. âš ï¸ **æ¶æ„å·®å¼‚**: gen_statem + PCB vs å›è°ƒå¼ API

**åè®®å…¼å®¹æ€§**: âœ… **å®Œå…¨å…¼å®¹** - å‘é€ç­–ç•¥å·®å¼‚ä¸å½±å“äº’æ“ä½œæ€§

---

## 7. ç»“è®º

### 7.1 å½“å‰å®ç°è¯„ä¼°

**ä¼˜ç‚¹**:
1. âœ… **è®¾è®¡ä¼˜ç§€**: æ¸…æ™°çš„æ•°æ®æµï¼ˆoutque â†’ outbufï¼‰
2. âœ… **ä¼˜åŒ–åˆ°ä½**: å°åŒ…åˆå¹¶ã€iolistã€ç«‹å³åˆ·æ–°
3. âœ… **å¯ç»´æŠ¤æ€§é«˜**: çº¯ Erlang å®ç°ï¼Œæ— å¤–éƒ¨ä¾èµ–
4. âœ… **åè®®å¯¹é½**: ä¸ libutp å‘é€ç­–ç•¥é«˜åº¦ä¸€è‡´

**ç¼ºç‚¹**:
1. âš ï¸ **ç³»ç»Ÿè°ƒç”¨**: æ¯åŒ…ä¸€æ¬¡ï¼ˆä½†å½±å“æœ‰é™ï¼‰
2. âš ï¸ **å¯è§‚æµ‹æ€§**: ç¼ºå°‘æ€§èƒ½ç›‘æ§æŒ‡æ ‡

### 7.2 ä¼˜åŒ–ä¼˜å…ˆçº§

**ç«‹å³æ‰§è¡Œ**:
- âœ… **ä¿æŒç°çŠ¶** - æ— æ˜æ˜¾æ€§èƒ½ç“¶é¢ˆéœ€è¦ç«‹å³è§£å†³

**çŸ­æœŸï¼ˆ1-3 ä¸ªæœˆï¼‰**:
- ğŸ“Š **ç›‘æ§å¢å¼º**: æ·»åŠ ç¼“å†²åŒºä½¿ç”¨ã€ååé‡æŒ‡æ ‡
- ğŸ“Š **åŸºå‡†æµ‹è¯•**: å»ºç«‹æ€§èƒ½åŸºå‡†æ•°æ®

**ä¸­æœŸï¼ˆ3-6 ä¸ªæœˆï¼‰**:
- ğŸ“Š **è‡ªé€‚åº”å®šæ—¶å™¨**: æ ¹æ®è´Ÿè½½è°ƒæ•´ tick é—´éš”ï¼ˆå¯é€‰ï¼‰

**é•¿æœŸï¼ˆ6+ ä¸ªæœˆï¼‰**:
- â¸ï¸ **æ‰¹é‡å‘é€**: ä»…å½“æ€§èƒ½æµ‹è¯•è¯æ˜å¿…è¦æ—¶è€ƒè™‘

### 7.3 æœ€ç»ˆå»ºè®®

**æ ¸å¿ƒå»ºè®®**: ğŸ¯ **å½“å‰å®ç°å·²ä¼˜åŒ–è‰¯å¥½ï¼Œæ— éœ€å¤§è§„æ¨¡é‡æ„**

**ç†ç”±**:
1. aiutp çš„å‘é€æµç¨‹å·²åŒ…å«å…³é”®ä¼˜åŒ–ï¼ˆå°åŒ…åˆå¹¶ã€ç«‹å³åˆ·æ–°ï¼‰
2. ä¸ libutp å‚è€ƒå®ç°ç­–ç•¥ä¸€è‡´
3. Erlang VM çš„ç³»ç»Ÿè°ƒç”¨å¼€é”€åœ¨å¯æ¥å—èŒƒå›´å†…
4. LEDBAT æ‹¥å¡æ§åˆ¶æœ¬èº«ä¼šé™åˆ¶å‘é€é€Ÿç‡

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**:
1. ğŸ“Š **å»ºç«‹æ€§èƒ½åŸºå‡†**: ç”¨å®é™…æ•°æ®éªŒè¯ä¼˜åŒ–å¿…è¦æ€§
2. ğŸ“Š **å¢åŠ ç›‘æ§**: æé«˜ç³»ç»Ÿå¯è§‚æµ‹æ€§
3. â¸ï¸ **æŒ‰éœ€ä¼˜åŒ–**: ç­‰å¾…æ€§èƒ½ç“¶é¢ˆå‡ºç°å†é’ˆå¯¹æ€§ä¼˜åŒ–

**æƒè¡¡è€ƒè™‘**:
- **å»¶è¿Ÿ vs ååé‡**: å½“å‰å®ç°åå‘ä½å»¶è¿Ÿï¼ˆç¬¦åˆ LEDBAT ç†å¿µï¼‰
- **ç®€å•æ€§ vs æ€§èƒ½**: ä¿æŒçº¯ Erlang å®ç°æ¯”æŒ¤å‹æœ€å 10% æ€§èƒ½æ›´é‡è¦
- **å¯ç»´æŠ¤æ€§ vs ä¼˜åŒ–**: é¿å…è¿‡æ—©ä¼˜åŒ–å¯¼è‡´ä»£ç å¤æ‚åŒ–

---

## 8. å‚è€ƒèµ„æ–™

### 8.1 libutp ç›¸å…³

- [BitTorrent libutp GitHub](https://github.com/bittorrent/libutp) - å®˜æ–¹ C++ å®ç°
- [libutp README](https://github.com/bittorrent/libutp/blob/master/README.md) - API æ–‡æ¡£
- [libutp utp_internal.cpp](https://github.com/bittorrent/libutp/blob/master/utp_internal.cpp) - æ ¸å¿ƒå®ç°

### 8.2 Nagle ç®—æ³•

- [Understanding the Nagle Algorithm Simplified](https://synchronet.net/nagle-algorithm/)
- [Tiny Packets, Big Delays: How Nagle's Algorithm Works](https://medium.com/@ariyanwaliya/tiny-packets-big-delays-how-nagles-algorithm-works-ef83203c4089)
- [Batch or Burst? Disabling Nagle's Algorithm with TCP_NODELAY](https://medium.com/@mohllal/batch-or-burst-disabling-nagles-algorithm-with-tcp-nodelay-for-better-latency-590b279175e6)

### 8.3 åè®®è§„èŒƒ

- [BEP-29: uTorrent Transport Protocol](https://www.bittorrent.org/beps/bep_0029.html)
- [RFC 6817: LEDBAT Congestion Control](https://datatracker.ietf.org/doc/html/rfc6817)

### 8.4 é¡¹ç›®æ–‡æ¡£

- [aiutp libutp å·®å¼‚åˆ†æ](./libutp-difference-analysis-2025-12-04.md)
- [LEDBAT æ‹¥å¡æ§åˆ¶](../development/ledbat-congestion-control.md)
- [æ•°æ®å‘é€æµç¨‹](../development/data-sending-flow.md)

---

**æŠ¥å‘Šç”Ÿæˆ**: 2025-12-04
**åˆ†æè€…**: Erlang ä¸“å®¶ (Claude Code)
**ç‰ˆæœ¬**: 1.0
